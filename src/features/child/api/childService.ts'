// features/child/api/childService.ts
import { db } from '@lib/firebase/config';
import { 
  collection, 
  doc, 
  getDoc, 
  getDocs, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  orderBy,
  arrayUnion,
  arrayRemove,
  Timestamp
} from 'firebase/firestore';
import { Child } from '@features/child/types';

// Convert Firestore timestamps to Date objects
const convertTimestamps = (data: any): any => {
  const converted = { ...data };
  
  // Convert Timestamp fields to Date objects
  Object.keys(converted).forEach(key => {
    if (converted[key] instanceof Timestamp) {
      converted[key] = converted[key].toDate();
    } else if (converted[key] && typeof converted[key] === 'object') {
      // Recursively convert nested objects
      if (converted[key].timestamp instanceof Timestamp) {
        converted[key].timestamp = converted[key].timestamp.toDate();
      }
    }
  });
  
  return converted;
};

// Get children by guardian/parent ID
export const getChildrenByGuardian = async (guardianId: string): Promise<Child[]> => {
  try {
    // Query children where the guardian is in the guardians array
    const q = query(
      collection(db, 'children'),
      where('guardians', 'array-contains', { 
        id: guardianId, 
        status: 'approved' 
      })
    );
    
    let snapshot = await getDocs(q);
    let children = snapshot.docs.map(doc => ({
      id: doc.id,
      ...convertTimestamps(doc.data())
    } as Child));

    // If no children found with guardians array, try legacy parentId field
    if (children.length === 0) {
      const legacyQuery = query(
        collection(db, 'children'),
        where('parentId', '==', guardianId)
      );
      
      snapshot = await getDocs(legacyQuery);
      children = snapshot.docs.map(doc => ({
        id: doc.id,
        ...convertTimestamps(doc.data())
      } as Child));
    }

    // If still no children found, try guardianId field
    if (children.length === 0) {
      const guardianQuery = query(
        collection(db, 'children'),
        where('guardianId', '==', guardianId)
      );
      
      snapshot = await getDocs(guardianQuery);
      children = snapshot.docs.map(doc => ({
        id: doc.id,
        ...convertTimestamps(doc.data())
      } as Child));
    }

    return children;
  } catch (error) {
    console.error('Error fetching children by guardian:', error);
    throw new Error('Failed to fetch children data');
  }
};

// Get a single child by ID
export const getChildById = async (childId: string): Promise<Child | null> => {
  try {
    const childDoc = await getDoc(doc(db, 'children', childId));
    
    if (!childDoc.exists()) {
      return null;
    }

    return {
      id: childDoc.id,
      ...convertTimestamps(childDoc.data())
    } as Child;
  } catch (error) {
    console.error('Error fetching child by ID:', error);
    throw new Error('Failed to fetch child data');
  }
};

// Create a new child
export const createChild = async (childData: Omit<Child, 'id'>): Promise<string> => {
  try {
    const docRef = await addDoc(collection(db, 'children'), {
      ...childData,
      createdAt: new Date(),
      updatedAt: new Date()
    });
    
    return docRef.id;
  } catch (error) {
    console.error('Error creating child:', error);
    throw new Error('Failed to create child');
  }
};

// Update a child
export const updateChild = async (childId: string, updates: Partial<Child>): Promise<void> => {
  try {
    const childRef = doc(db, 'children', childId);
    await updateDoc(childRef, {
      ...updates,
      updatedAt: new Date()
    });
  } catch (error) {
    console.error('Error updating child:', error);
    throw new Error('Failed to update child');
  }
};

// Delete a child
export const deleteChild = async (childId: string): Promise<void> => {
  try {
    await deleteDoc(doc(db, 'children', childId));
  } catch (error) {
    console.error('Error deleting child:', error);
    throw new Error('Failed to delete child');
  }
};

// Add guardian to child
export const addGuardianToChild = async (
  childId: string, 
  guardianId: string, 
  guardianEmail: string
): Promise<void> => {
  try {
    const childRef = doc(db, 'children', childId);
    await updateDoc(childRef, {
      guardians: arrayUnion({
        id: guardianId,
        status: 'pending',
        email: guardianEmail
      }),
      updatedAt: new Date()
    });
  } catch (error) {
    console.error('Error adding guardian to child:', error);
    throw new Error('Failed to add guardian');
  }
};

// Remove guardian from child
export const removeGuardianFromChild = async (
  childId: string, 
  guardianId: string
): Promise<void> => {
  try {
    const child = await getChildById(childId);
    if (!child?.guardians) return;

    const guardianToRemove = child.guardians.find(g => g.id === guardianId);
    if (!guardianToRemove) return;

    const childRef = doc(db, 'children', childId);
    await updateDoc(childRef, {
      guardians: arrayRemove(guardianToRemove),
      updatedAt: new Date()
    });
  } catch (error) {
    console.error('Error removing guardian from child:', error);
    throw new Error('Failed to remove guardian');
  }
};

// Approve guardian request
export const approveGuardianRequest = async (
  childId: string, 
  guardianId: string
): Promise<void> => {
  try {
    const child = await getChildById(childId);
    if (!child?.guardians) return;

    // Find and update the guardian status
    const updatedGuardians = child.guardians.map(guardian => 
      guardian.id === guardianId 
        ? { ...guardian, status: 'approved' as const }
        : guardian
    );

    const childRef = doc(db, 'children', childId);
    await updateDoc(childRef, {
      guardians: updatedGuardians,
      updatedAt: new Date()
    });
  } catch (error) {
    console.error('Error approving guardian request:', error);
    throw new Error('Failed to approve guardian request');
  }
};

// Update child's last seen location
export const updateChildLocation = async (
  childId: string, 
  location: string
): Promise<void> => {
  try {
    const childRef = doc(db, 'children', childId);
    await updateDoc(childRef, {
      lastSeen: {
        location,
        timestamp: new Date()
      },
      updatedAt: new Date()
    });
  } catch (error) {
    console.error('Error updating child location:', error);
    throw new Error('Failed to update location');
  }
};

// Get all children (admin function)
export const getAllChildren = async (): Promise<Child[]> => {
  try {
    const q = query(collection(db, 'children'), orderBy('createdAt', 'desc'));
    const snapshot = await getDocs(q);
    
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...convertTimestamps(doc.data())
    } as Child));
  } catch (error) {
    console.error('Error fetching all children:', error);
    throw new Error('Failed to fetch children data');
  }
};